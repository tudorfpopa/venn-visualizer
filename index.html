<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Venn Diagram Visualizer</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f5f5f5;
            min-height: 100vh;
            width: 100vw;
            height: 100vh;
            display: flex;
            padding: 0;
            margin: 0;
            overflow: hidden;
        }

        #canvas-container {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            min-width: 0;
            min-height: 0;
            overflow: hidden;
            margin: 10px;
        }

        canvas {
            max-width: 100%;
            max-height: 100%;
            width: auto;
            height: auto;
        }

        #control-panel {
            width: 300px;
            background: white;
            box-shadow: -4px 0 20px rgba(0,0,0,0.1);
            padding: 20px;
            z-index: 100;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
            transition: transform 0.3s ease, opacity 0.3s ease;
            font-family: 'JetBrains Mono', monospace;
        }

        #control-panel.hidden {
            transform: translateX(100%);
            opacity: 0;
            pointer-events: none;
            width: 0;
            padding: 0;
            overflow: hidden;
        }

        #toggle-panel-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 44px;
            height: 44px;
            background: white;
            border: none;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.15);
            cursor: pointer;
            z-index: 101;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            color: #333;
            transition: background 0.2s, transform 0.2s;
        }

        #toggle-panel-btn:hover {
            background: #f8fafc;
            transform: scale(1.05);
        }

        #toggle-panel-btn.hidden {
            display: none;
        }

        @media (max-width: 900px) {
            body {
                flex-direction: column;
                height: auto;
                min-height: 100vh;
                overflow: auto;
            }

            #control-panel {
                width: 100%;
                box-shadow: 0 -4px 20px rgba(0,0,0,0.1);
                order: -1;
            }

            #canvas-container {
                width: 100%;
                min-height: 300px;
                margin: 10px;
            }
        }

        #control-panel h2 {
            font-size: 16px;
            margin-bottom: 15px;
            color: #333;
            font-weight: 600;
        }

        .input-group {
            margin-bottom: 15px;
        }

        .input-group label {
            display: block;
            font-size: 12px;
            color: #666;
            margin-bottom: 5px;
            font-weight: 500;
        }

        #expression-input {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            font-family: 'JetBrains Mono', monospace;
            transition: border-color 0.2s;
        }

        #expression-input:focus {
            outline: none;
            border-color: #6366f1;
        }

        #error-message {
            color: #ef4444;
            font-size: 12px;
            margin-top: 5px;
            min-height: 16px;
        }

        .step-info {
            background: #f8fafc;
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 15px;
        }

        .step-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .step-number {
            font-size: 12px;
            color: #6366f1;
            font-weight: 600;
        }

        .step-type {
            font-size: 11px;
            padding: 3px 8px;
            background: #e0e7ff;
            color: #4338ca;
            border-radius: 4px;
            font-weight: 500;
        }

        .step-description {
            font-size: 13px;
            color: #475569;
            line-height: 1.4;
        }

        .nav-buttons {
            display: flex;
            gap: 8px;
            margin-bottom: 15px;
        }

        .nav-btn {
            flex: 1;
            padding: 8px 12px;
            border: 1px solid #e2e8f0;
            background: white;
            border-radius: 6px;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
        }

        .nav-btn:hover:not(:disabled) {
            background: #f8fafc;
            border-color: #cbd5e1;
        }

        .nav-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .settings-row {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }

        .settings-row .input-group {
            flex: 1;
            margin-bottom: 0;
        }

        select {
            width: 100%;
            padding: 8px 10px;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            font-size: 13px;
            background: white;
            cursor: pointer;
        }

        select:focus {
            outline: none;
            border-color: #6366f1;
        }

        .slider-container {
            margin-bottom: 15px;
        }

        .slider-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .slider-header label {
            font-size: 12px;
            color: #666;
        }

        .slider-value {
            font-size: 12px;
            color: #333;
            font-weight: 500;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #e2e8f0;
            appearance: none;
            cursor: pointer;
        }

        input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #6366f1;
            cursor: pointer;
            transition: transform 0.1s;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.1);
        }

        .shortcuts {
            border-top: 1px solid #e2e8f0;
            padding-top: 15px;
            margin-top: 15px;
        }

        .shortcuts-title {
            font-size: 11px;
            color: #94a3b8;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .shortcut {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            color: #64748b;
            margin-bottom: 4px;
        }

        .shortcut kbd {
            background: #f1f5f9;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: inherit;
            font-size: 11px;
        }

        #region-labels-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 15px;
        }

        #region-labels-toggle input[type="checkbox"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }

        #region-labels-toggle label {
            font-size: 13px;
            color: #475569;
            cursor: pointer;
        }

        #expression-display {
            min-height: 42px;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 18px;
            font-family: 'JetBrains Mono', monospace;
            background: #f8fafc;
            color: #1e293b;
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 1px;
            word-break: break-all;
            transition: border-color 0.2s;
        }

        #expression-display:focus-within,
        #expression-display.active {
            border-color: #6366f1;
            background: #fff;
        }

        #expression-display .cursor {
            display: inline-block;
            color: #6366f1;
            font-weight: 300;
            animation: blink 1s step-end infinite;
            margin-left: 1px;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50%       { opacity: 0; }
        }

        .symbol-buttons {
            display: flex;
            flex-direction: column;
            gap: 6px;
            margin-bottom: 15px;
        }

        .symbol-row {
            display: flex;
            gap: 6px;
        }

        .sym-btn {
            flex: 1;
            padding: 10px 4px;
            font-size: 16px;
            font-family: 'JetBrains Mono', monospace;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            background: white;
            color: #1e293b;
            cursor: pointer;
            transition: background 0.15s, border-color 0.15s, transform 0.1s;
            user-select: none;
        }

        .sym-btn:hover {
            background: #f1f5f9;
            border-color: #cbd5e1;
        }

        .sym-btn:active {
            transform: scale(0.93);
            background: #e0e7ff;
            border-color: #6366f1;
        }

        .var-btn {
            font-weight: 600;
            color: #4338ca;
            border-color: #c7d2fe;
            background: #eef2ff;
        }

        .var-btn:hover {
            background: #e0e7ff;
            border-color: #a5b4fc;
        }

        .action-btn {
            font-size: 13px;
            color: #64748b;
        }

        #clear-btn {
            color: #ef4444;
            border-color: #fecaca;
            background: #fff5f5;
        }

        #clear-btn:hover {
            background: #fee2e2;
            border-color: #fca5a5;
        }
    </style>
</head>
<body>
    <div id="canvas-container">
        <div id="venn-container" style="width: 100%; height: 100%; display: flex; justify-content: center; align-items: center;"></div>
    </div>

    <div id="control-panel">
            <h2>Venn Diagram Visualizer</h2>

            <div class="input-group">
                <label>Expression</label>
                <div id="expression-display"><span id="expression-text"></span><span class="cursor">|</span></div>
                <div id="error-message"></div>
            </div>

            <div class="symbol-buttons">
                <div class="symbol-row">
                    <button class="sym-btn var-btn" data-insert="A">A</button>
                    <button class="sym-btn var-btn" data-insert="B">B</button>
                    <button class="sym-btn var-btn" data-insert="C">C</button>
                    <button class="sym-btn" data-insert="′">′</button>
                </div>
                <div class="symbol-row">
                    <button class="sym-btn" data-insert="∪">∪</button>
                    <button class="sym-btn" data-insert="∩">∩</button>
                    <button class="sym-btn" data-insert="(">(</button>
                    <button class="sym-btn" data-insert=")">)</button>
                </div>
                <div class="symbol-row">
                    <button class="sym-btn action-btn" id="clear-btn">Clear</button>
                    <button class="sym-btn action-btn" id="backspace-btn">⌫</button>
                </div>
            </div>

            <div class="step-info" id="step-info" style="display: none;">
                <div class="step-header">
                    <span class="step-number" id="step-number">Step 1 of 7</span>
                    <span class="step-type" id="step-type">Parse</span>
                </div>
                <div class="step-description" id="step-description">
                    Parsing the expression...
                </div>
            </div>

            <div class="nav-buttons">
                <button class="nav-btn" id="prev-btn" disabled>◀ Prev</button>
                <button class="nav-btn" id="play-btn">▶ Play</button>
                <button class="nav-btn" id="next-btn" disabled>Next ▶</button>
                <button class="nav-btn" id="reset-btn">R Reset</button>
            </div>

            <div class="slider-container">
                <div class="slider-header">
                    <label>Opacity</label>
                    <span class="slider-value" id="opacity-value">60%</span>
                </div>
                <input type="range" id="opacity-slider" min="10" max="100" value="60">
            </div>

            <div id="region-labels-toggle">
                <input type="checkbox" id="show-labels" checked>
                <label for="show-labels">Show region labels</label>
            </div>

            <div class="shortcuts">
                <div class="shortcuts-title">Keyboard Shortcuts</div>
                <div class="shortcut"><span>Previous step</span><kbd>←</kbd></div>
                <div class="shortcut"><span>Next step</span><kbd>→</kbd></div>
                <div class="shortcut"><span>Play/Pause</span><kbd>Space</kbd></div>
                <div class="shortcut"><span>Reset</span><kbd>R</kbd></div>
                <div class="shortcut"><span>Backspace</span><kbd>⌫</kbd></div>
            </div>

            <button id="hide-panel-btn" style="margin-top: 15px; padding: 10px; background: #f1f5f9; border: 1px solid #e2e8f0; border-radius: 6px; cursor: pointer; width: 100%;">Hide Panel</button>
        </div>

    <button id="toggle-panel-btn" class="hidden">☰</button>

    <script>
        // ==================== TOKENIZER ====================
        // Symbols: ∪ = union (OR), ∩ = intersection (AND), ′ or ' = complement (postfix NOT)
        class Tokenizer {
            constructor(expression) {
                this.expression = expression;
                this.pos = 0;
                this.tokens = [];
            }

            tokenize() {
                while (this.pos < this.expression.length) {
                    const char = this.expression[this.pos];

                    if (/\s/.test(char)) {
                        this.pos++;
                        continue;
                    }

                    if (/[A-Ca-c]/.test(char)) {
                        this.tokens.push({ type: 'VARIABLE', value: char.toUpperCase() });
                        this.pos++;
                    } else if (char === '∪') {
                        this.tokens.push({ type: 'UNION', value: '∪' });
                        this.pos++;
                    } else if (char === '∩') {
                        this.tokens.push({ type: 'INTERSECT', value: '∩' });
                        this.pos++;
                    } else if (char === '′' || char === "'") {
                        this.tokens.push({ type: 'COMPLEMENT', value: '′' });
                        this.pos++;
                    } else if (char === '(') {
                        this.tokens.push({ type: 'LPAREN', value: '(' });
                        this.pos++;
                    } else if (char === ')') {
                        this.tokens.push({ type: 'RPAREN', value: ')' });
                        this.pos++;
                    } else {
                        throw new Error(`Invalid character: ${char}`);
                    }
                }
                return this.tokens;
            }
        }

        // ==================== PARSER ====================
        // Grammar (precedence low → high):
        //   expr       → union
        //   union      → intersect ( ∪ intersect )*
        //   intersect  → postfix   ( ∩ postfix   )*
        //   postfix    → primary ′*
        //   primary    → VARIABLE | '(' expr ')'
        class Parser {
            constructor(tokens) {
                this.tokens = tokens;
                this.pos = 0;
            }

            parse() {
                if (this.tokens.length === 0) throw new Error('Empty expression');
                const ast = this.parseUnion();
                if (this.pos < this.tokens.length) {
                    throw new Error(`Unexpected token: ${this.tokens[this.pos].value}`);
                }
                return ast;
            }

            parseUnion() {
                let left = this.parseIntersect();
                while (this.match('UNION')) {
                    const right = this.parseIntersect();
                    left = { type: 'OR', left, right };
                }
                return left;
            }

            parseIntersect() {
                let left = this.parsePostfix();
                while (this.match('INTERSECT')) {
                    const right = this.parsePostfix();
                    left = { type: 'AND', left, right };
                }
                return left;
            }

            parsePostfix() {
                let node = this.parsePrimary();
                while (this.match('COMPLEMENT')) {
                    node = { type: 'NOT', operand: node };
                }
                return node;
            }

            parsePrimary() {
                if (this.match('VARIABLE')) {
                    return { type: 'VARIABLE', value: this.tokens[this.pos - 1].value };
                }
                if (this.match('LPAREN')) {
                    const expr = this.parseUnion();
                    if (!this.match('RPAREN')) {
                        throw new Error('Missing closing parenthesis');
                    }
                    return expr;
                }
                throw new Error(`Unexpected token: ${this.tokens[this.pos]?.value || 'end of input'}`);
            }

            match(type) {
                if (this.pos < this.tokens.length && this.tokens[this.pos].type === type) {
                    this.pos++;
                    return true;
                }
                return false;
            }
        }

        // ==================== REGION MAPPER ====================
        class RegionMapper {
            static getRegionsForVariable(variable) {
                switch (variable) {
                    case 'A': return [1, 3, 5, 7];
                    case 'B': return [2, 3, 6, 7];
                    case 'C': return [4, 5, 6, 7];
                    default: return [];
                }
            }

            static getRegionsForAST(node) {
                switch (node.type) {
                    case 'VARIABLE':
                        return this.getRegionsForVariable(node.value);
                    case 'NOT':
                        const notRegions = this.getRegionsForAST(node.operand);
                        return [0, 1, 2, 3, 4, 5, 6, 7].filter(r => !notRegions.includes(r));
                    case 'AND':
                        const leftAnd = this.getRegionsForAST(node.left);
                        const rightAnd = this.getRegionsForAST(node.right);
                        return leftAnd.filter(r => rightAnd.includes(r));
                    case 'OR':
                        const leftOr = this.getRegionsForAST(node.left);
                        const rightOr = this.getRegionsForAST(node.right);
                        return [...new Set([...leftOr, ...rightOr])].sort((a, b) => a - b);
                    default:
                        return [];
                }
            }
        }

        // ==================== STEP GENERATOR ====================
        class StepGenerator {
            constructor() {
                this.steps = [];
            }

            generateSteps(ast, originalExpression) {
                this.steps = [];
                this.breakDownExpression(ast);
                return this.steps;
            }

            breakDownExpression(node, context = '') {
                if (!node) return;

                if (node.type === 'VARIABLE') {
                    const regions = RegionMapper.getRegionsForAST(node);
                    this.steps.push({
                        stepNumber: this.steps.length + 1,
                        type: 'Variable',
                        description: `Evaluate ${node.value}`,
                        expression: node.value,
                        regions: regions,
                        ast: node
                    });
                    return;
                }

                if (node.type === 'NOT') {
                    // First, break down the operand to show all its steps
                    this.breakDownExpression(node.operand, 'NOT');
                    
                    // Then add the negation step
                    const regions = RegionMapper.getRegionsForAST(node);
                    const operandExpr = this.astToString(node.operand);
                    this.steps.push({
                        stepNumber: this.steps.length + 1,
                        type: 'Negation',
                        description: `Apply NOT to result of (${operandExpr})`,
                        expression: `NOT (${operandExpr})`,
                        regions: regions,
                        ast: node
                    });
                    return;
                }

                if (node.type === 'AND' || node.type === 'OR') {
                    // Break down left side
                    this.breakDownExpression(node.left);
                    // Break down right side
                    this.breakDownExpression(node.right);
                    
                    // Combine them
                    const regions = RegionMapper.getRegionsForAST(node);
                    const leftExpr = this.astToString(node.left);
                    const rightExpr = this.astToString(node.right);
                    
                    this.steps.push({
                        stepNumber: this.steps.length + 1,
                        type: node.type === 'AND' ? 'Intersection' : 'Union',
                        description: `Combine (${leftExpr}) ${node.type} (${rightExpr})`,
                        expression: `(${leftExpr}) ${node.type} (${rightExpr})`,
                        regions: regions,
                        ast: node
                    });
                }
            }

            astToString(node) {
                if (!node) return '';
                if (node.type === 'VARIABLE') return node.value;
                if (node.type === 'NOT') return `(${this.astToString(node.operand)})′`;
                if (node.type === 'AND') return `(${this.astToString(node.left)} ∩ ${this.astToString(node.right)})`;
                if (node.type === 'OR')  return `(${this.astToString(node.left)} ∪ ${this.astToString(node.right)})`;
                return '';
            }

            extractVariables(node) {
                if (!node) return [];
                if (node.type === 'VARIABLE') return [node.value];
                if (node.type === 'NOT') return this.extractVariables(node.operand);
                if (node.type === 'AND' || node.type === 'OR') {
                    return [...new Set([...this.extractVariables(node.left), ...this.extractVariables(node.right)])].sort();
                }
                return [];
            }

            describeRegions(regions) {
                const names = {
                    0: 'outside',
                    1: 'A only',
                    2: 'B only',
                    3: 'A∩B',
                    4: 'C only',
                    5: 'A∩C',
                    6: 'B∩C',
                    7: 'A∩B∩C'
                };
                return regions.map(r => names[r]).join(', ');
            }
        }

        // ==================== VENN RENDERER ====================
        class VennRenderer {
            constructor(container) {
                this.container = container;
                this.width = 600;
                this.height = 600;
                this.svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                this.svg.setAttribute("viewBox", `0 0 ${this.width} ${this.height}`);
                this.svg.style.width = "100%";
                this.svg.style.height = "100%";
                this.container.appendChild(this.svg);

                this.calculateDimensions();
                this.createDefinitions();
                this.createRegionElements();
            }

            calculateDimensions() {
                this.samplePadding = Math.min(this.width, this.height) * 0.08;
                this.sampleRect = {
                    x: this.samplePadding,
                    y: this.samplePadding,
                    width: this.width - this.samplePadding * 2,
                    height: this.height - this.samplePadding * 2
                };

                const sampleCenterX = this.sampleRect.x + this.sampleRect.width / 2;
                const sampleCenterY = this.sampleRect.y + this.sampleRect.height / 2;
                const minDim = Math.min(this.sampleRect.width, this.sampleRect.height);

                this.circleRadius = minDim * 0.28;
                const offsetY = minDim * 0.15;
                const offsetX = minDim * 0.18;

                this.circleCenters = {
                    A: { x: sampleCenterX, y: sampleCenterY - offsetY },
                    B: { x: sampleCenterX - offsetX, y: sampleCenterY + offsetY },
                    C: { x: sampleCenterX + offsetX, y: sampleCenterY + offsetY }
                };
            }

            createDefinitions() {
                const defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");

                // Clip Paths
                ['A', 'B', 'C'].forEach(key => {
                    const clip = document.createElementNS("http://www.w3.org/2000/svg", "clipPath");
                    clip.id = `clip-${key}`;
                    const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                    circle.setAttribute("cx", this.circleCenters[key].x);
                    circle.setAttribute("cy", this.circleCenters[key].y);
                    circle.setAttribute("r", this.circleRadius);
                    clip.appendChild(circle);
                    defs.appendChild(clip);
                });

                // Patterns
                const createPattern = (id, width, height, content) => {
                    const p = document.createElementNS("http://www.w3.org/2000/svg", "pattern");
                    p.setAttribute("id", id);
                    p.setAttribute("patternUnits", "userSpaceOnUse");
                    p.setAttribute("width", width);
                    p.setAttribute("height", height);
                    p.innerHTML = content;
                    defs.appendChild(p);
                };

                // Base templates use COLOR_PLACEHOLDER, substituted at render time
                this.patternTemplates = {
                    diagonal:   { w: 10, h: 10, content: (c) => `<path d="M-1,1 l2,-2 M0,10 l10,-10 M9,11 l2,-2" stroke="${c}" stroke-width="1.5" />` },
                    crosshatch: { w: 10, h: 10, content: (c) => `<path d="M0,0 l10,10 M10,0 l-10,10" stroke="${c}" stroke-width="1.5" />` },
                    dots:       { w: 10, h: 10, content: (c) => `<circle cx="5" cy="5" r="2" fill="${c}" />` },
                    waves:      { w: 20, h: 10, content: (c) => `<path d="M0,5 Q5,0 10,5 T20,5" fill="none" stroke="${c}" stroke-width="1.5" />` },
                    grid:       { w: 15, h: 15, content: (c) => `<path d="M 15 0 L 0 0 0 15" fill="none" stroke="${c}" stroke-width="1.5" />` },
                };

                this.svg.appendChild(defs);
            }

            createRegionElements() {
                // Background (Sample Space)
                const sampleG = document.createElementNS("http://www.w3.org/2000/svg", "g");
                const sampleRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                sampleRect.setAttribute("x", this.sampleRect.x);
                sampleRect.setAttribute("y", this.sampleRect.y);
                sampleRect.setAttribute("width", this.sampleRect.width);
                sampleRect.setAttribute("height", this.sampleRect.height);
                sampleRect.setAttribute("fill", "none");
                sampleRect.setAttribute("stroke", "#1e293b");
                sampleRect.setAttribute("stroke-width", "2");
                sampleG.appendChild(sampleRect);

                const sampleText = document.createElementNS("http://www.w3.org/2000/svg", "text");
                sampleText.setAttribute("x", this.sampleRect.x + 12);
                sampleText.setAttribute("y", this.sampleRect.y + 20);
                sampleText.setAttribute("fill", "#64748b");
                sampleText.textContent = "S";
                sampleText.style.font = "italic 14px serif";
                sampleG.appendChild(sampleText);
                this.svg.appendChild(sampleG);

                // Regions Layer
                this.regionsLayer = document.createElementNS("http://www.w3.org/2000/svg", "g");
                this.svg.appendChild(this.regionsLayer);

                this.regionElements = {};
                for (let i = 0; i < 8; i++) {
                    const el = this.buildRegionElement(i);
                    el.style.display = 'none';
                    this.regionsLayer.appendChild(el);
                    this.regionElements[i] = el;
                }

                // Boundaries
                const boundariesG = document.createElementNS("http://www.w3.org/2000/svg", "g");
                ['A', 'B', 'C'].forEach(key => {
                    const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                    circle.setAttribute("cx", this.circleCenters[key].x);
                    circle.setAttribute("cy", this.circleCenters[key].y);
                    circle.setAttribute("r", this.circleRadius);
                    circle.setAttribute("fill", "none");
                    circle.setAttribute("stroke", "#1e293b");
                    circle.setAttribute("stroke-width", "2");
                    boundariesG.appendChild(circle);
                });
                this.svg.appendChild(boundariesG);

                // Labels Layer
                this.labelsLayer = document.createElementNS("http://www.w3.org/2000/svg", "g");
                this.svg.appendChild(this.labelsLayer);
                
                this.drawSetLabels();
            }

            buildRegionElement(regionIndex) {
                const included = this.getRegionCircles(regionIndex);
                const all = ['A', 'B', 'C'];
                const excluded = all.filter(x => !included.includes(x));

                let content = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                content.setAttribute("x", this.sampleRect.x);
                content.setAttribute("y", this.sampleRect.y);
                content.setAttribute("width", this.sampleRect.width);
                content.setAttribute("height", this.sampleRect.height);
                content.classList.add("region-fill-rect");

                if (excluded.length > 0) {
                    const maskId = `mask-exclude-${excluded.join('')}`;
                    if (!document.getElementById(maskId)) {
                        const mask = document.createElementNS("http://www.w3.org/2000/svg", "mask");
                        mask.id = maskId;
                        
                        const bg = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                        bg.setAttribute("x", 0);
                        bg.setAttribute("y", 0);
                        bg.setAttribute("width", "100%");
                        bg.setAttribute("height", "100%");
                        bg.setAttribute("fill", "white");
                        mask.appendChild(bg);

                        excluded.forEach(key => {
                            const c = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                            c.setAttribute("cx", this.circleCenters[key].x);
                            c.setAttribute("cy", this.circleCenters[key].y);
                            c.setAttribute("r", this.circleRadius);
                            c.setAttribute("fill", "black");
                            mask.appendChild(c);
                        });
                        this.svg.querySelector("defs").appendChild(mask);
                    }
                    content.setAttribute("mask", `url(#${maskId})`);
                }

                let root = content;
                included.forEach(key => {
                    const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
                    g.setAttribute("clip-path", `url(#clip-${key})`);
                    g.appendChild(root);
                    root = g;
                });

                return root;
            }

            getRegionCircles(regionIndex) {
                const circles = {
                    0: [],
                    1: ['A'],
                    2: ['B'],
                    3: ['A', 'B'],
                    4: ['C'],
                    5: ['A', 'C'],
                    6: ['B', 'C'],
                    7: ['A', 'B', 'C']
                };
                return circles[regionIndex] || [];
            }

            resize() {
                // Not needed for SVG
            }

            render(shadedRegions, options = {}) {
                const { color = '#6366f1', pattern = 'solid', opacity = 0.6, showLabels = true } = options;

                Object.values(this.regionElements).forEach(el => el.style.display = 'none');

                // For non-solid patterns, ensure a color-baked pattern clone exists in defs
                let patternFillRef = color;
                if (pattern !== 'solid') {
                    const safeColor = color.replace('#', '');
                    const patternId = `pattern-${pattern}-${safeColor}`;
                    if (!this.svg.querySelector(`#${patternId}`)) {
                        const tmpl = this.patternTemplates[pattern];
                        if (tmpl) {
                            const p = document.createElementNS("http://www.w3.org/2000/svg", "pattern");
                            p.setAttribute("id", patternId);
                            p.setAttribute("patternUnits", "userSpaceOnUse");
                            p.setAttribute("width", tmpl.w);
                            p.setAttribute("height", tmpl.h);
                            p.innerHTML = tmpl.content(color);
                            this.svg.querySelector("defs").appendChild(p);
                        }
                    }
                    patternFillRef = `url(#pattern-${pattern}-${safeColor})`;
                }

                shadedRegions.forEach(index => {
                    const el = this.regionElements[index];
                    if (el) {
                        el.style.display = 'inline';

                        // Find the rect to update style
                        let rect = el;
                        while (rect && !rect.classList?.contains("region-fill-rect")) {
                            rect = rect.firstElementChild;
                        }

                        if (rect) {
                            rect.setAttribute("fill", patternFillRef);
                            rect.setAttribute("fill-opacity", opacity);
                        }
                    }
                });

                const labelsGroup = this.svg.querySelector("#region-labels-group");
                if (labelsGroup) {
                    labelsGroup.style.display = showLabels ? 'inline' : 'none';
                } else if (showLabels) {
                    this.drawLabels();
                }
            }

            drawLabels() {
                let g = this.svg.querySelector("#region-labels-group");
                if (!g) {
                    g = document.createElementNS("http://www.w3.org/2000/svg", "g");
                    g.id = "region-labels-group";
                    this.labelsLayer.appendChild(g);

                    const fontSize = Math.max(10, this.width * 0.018);
                    
                    const a = this.circleCenters.A;
                    const b = this.circleCenters.B;
                    const c = this.circleCenters.C;
                    const r = this.circleRadius * 0.4;

                    const positions = {
                        1: { x: a.x - r * 0.7, y: a.y - r * 0.4 },
                        2: { x: b.x - r * 0.3, y: b.y + r * 0.2 },
                        4: { x: c.x + r * 0.3, y: c.y + r * 0.2 },
                        3: { x: (a.x + b.x) / 2 - r * 0.2, y: (a.y + b.y) / 2 },
                        5: { x: (a.x + c.x) / 2 + r * 0.2, y: (a.y + c.y) / 2 },
                        6: { x: (b.x + c.x) / 2, y: (b.y + c.y) / 2 + r * 0.8 },
                        7: { x: (a.x + b.x + c.x) / 3, y: (a.y + b.y + c.y) / 3 }
                    };

                    const labels = { 1: 'A', 2: 'B', 4: 'C', 3: 'AB', 5: 'AC', 6: 'BC', 7: 'ABC' };

                    Object.entries(positions).forEach(([region, pos]) => {
                        const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
                        text.setAttribute("x", pos.x);
                        text.setAttribute("y", pos.y);
                        text.setAttribute("text-anchor", "middle");
                        text.setAttribute("fill", "#475569");
                        text.style.font = `${fontSize}px sans-serif`;
                        text.textContent = labels[region];
                        g.appendChild(text);
                    });
                }
                g.style.display = 'inline';
            }

            drawSetLabels() {
                const fontSize = Math.max(12, this.width * 0.028);
                const offset = this.circleRadius * 0.75;
                
                const createLabel = (text, x, y) => {
                    const t = document.createElementNS("http://www.w3.org/2000/svg", "text");
                    t.setAttribute("x", x);
                    t.setAttribute("y", y);
                    t.setAttribute("text-anchor", "middle");
                    t.setAttribute("fill", "#1e293b");
                    t.style.font = `bold ${fontSize}px sans-serif`;
                    t.textContent = text;
                    this.labelsLayer.appendChild(t);
                };

                createLabel('A', this.circleCenters.A.x, this.circleCenters.A.y - offset);
                createLabel('B', this.circleCenters.B.x - offset * 0.65, this.circleCenters.B.y + offset * 0.85);
                createLabel('C', this.circleCenters.C.x + offset * 0.65, this.circleCenters.C.y + offset * 0.85);
            }
        }

        // ==================== MAIN APPLICATION ====================
        class VennVisualizer {
            constructor() {
                this.container = document.getElementById('venn-container');
                this.renderer = new VennRenderer(this.container);
                this.expressionText = document.getElementById('expression-text');
                this.errorMessage = document.getElementById('error-message');
                this.stepInfo = document.getElementById('step-info');
                this.stepNumber = document.getElementById('step-number');
                this.stepType = document.getElementById('step-type');
                this.stepDescription = document.getElementById('step-description');
                this.prevBtn = document.getElementById('prev-btn');
                this.nextBtn = document.getElementById('next-btn');
                this.playBtn = document.getElementById('play-btn');
                this.resetBtn = document.getElementById('reset-btn');
                this.opacitySlider = document.getElementById('opacity-slider');
                this.opacityValue = document.getElementById('opacity-value');
                this.showLabelsCheckbox = document.getElementById('show-labels');
                this.controlPanel = document.getElementById('control-panel');
                this.togglePanelBtn = document.getElementById('toggle-panel-btn');
                this.hidePanelBtn = document.getElementById('hide-panel-btn');

                // Expression state — built by symbol buttons
                this.expression = '';

                this.steps = [];
                this.currentStep = 0;
                this.isPlaying = false;
                this.playInterval = null;
                this.panelVisible = true;

                this.colorPalette = [
                    '#6366f1', '#ef4444', '#22c55e', '#f59e0b',
                    '#8b5cf6', '#ec4899', '#14b8a6', '#64748b'
                ];

                this.patternOptions = ['solid', 'diagonal', 'crosshatch', 'dots', 'waves', 'grid'];

                this.opacity = 0.6;
                this.showLabels = true;
                this.stepPatterns = [];

                this.bindEvents();
                this.initialRender();
            }

            // Append a symbol to the expression and re-evaluate
            insertSymbol(sym) {
                this.expression += sym;
                this.expressionText.textContent = this.expression;
                this.errorMessage.textContent = '';
                this.visualize();
            }

            // Remove last character and re-evaluate
            backspace() {
                if (this.expression.length === 0) return;
                // Handle multi-byte characters (∪ ∩ ′ are single Unicode code points)
                this.expression = [...this.expression].slice(0, -1).join('');
                this.expressionText.textContent = this.expression;
                this.errorMessage.textContent = '';
                if (this.expression.length === 0) {
                    this.steps = [];
                    this.stepInfo.style.display = 'none';
                    this.initialRender();
                    this.updateNavigation();
                } else {
                    this.visualize();
                }
            }

            // Clear the entire expression
            clearExpression() {
                this.expression = '';
                this.expressionText.textContent = '';
                this.errorMessage.textContent = '';
                this.steps = [];
                this.stepInfo.style.display = 'none';
                this.initialRender();
                this.updateNavigation();
            }

            initialRender() {
                this.renderer.render([], {
                    color: '#6366f1',
                    pattern: 'solid',
                    opacity: this.opacity,
                    showLabels: this.showLabels
                });
            }

            visualize() {
                const expression = this.expression.trim();

                if (!expression) {
                    return;
                }

                try {
                    const tokenizer = new Tokenizer(expression);
                    const tokens = tokenizer.tokenize();

                    const parser = new Parser(tokens);
                    const ast = parser.parse();

                    const stepGenerator = new StepGenerator();
                    this.steps = stepGenerator.generateSteps(ast, expression);

                    this.stepPatterns = this.steps.map(() =>
                        this.patternOptions[Math.floor(Math.random() * this.patternOptions.length)]
                    );

                    this.stepColors = this.steps.map(() =>
                        this.colorPalette[Math.floor(Math.random() * this.colorPalette.length)]
                    );

                    this.currentStep = this.steps.length - 1;
                    this.errorMessage.textContent = '';

                    if (this.steps.length > 0) {
                        this.stepInfo.style.display = 'block';
                        this.updateStepDisplay();
                        this.updateNavigation();
                    }
                } catch (error) {
                    this.errorMessage.textContent = error.message;
                }
            }

            updateStepDisplay() {
                if (this.currentStep >= this.steps.length) {
                    this.currentStep = this.steps.length - 1;
                }

                if (this.currentStep < 0) {
                    this.currentStep = 0;
                }

                const step = this.steps[this.currentStep];
                const stepColor = (this.stepColors && this.stepColors[this.currentStep]) || this.colorPalette[this.currentStep % this.colorPalette.length];
                const stepPattern = this.stepPatterns[this.currentStep] || 'solid';

                this.stepNumber.textContent = `Step ${this.currentStep + 1} of ${this.steps.length}`;
                this.stepType.textContent = step.type;
                this.stepDescription.textContent = step.description;

                this.renderer.render(step.regions, {
                    color: stepColor,
                    pattern: stepPattern,
                    opacity: this.opacity,
                    showLabels: this.showLabels
                });
            }

            updateRender() {
                if (this.steps.length > 0 && this.currentStep < this.steps.length) {
                    const step = this.steps[this.currentStep];
                    const stepColor = (this.stepColors && this.stepColors[this.currentStep]) || this.colorPalette[this.currentStep % this.colorPalette.length];
                    const stepPattern = this.stepPatterns[this.currentStep] || 'solid';
                    this.renderer.render(step.regions, {
                        color: stepColor,
                        pattern: stepPattern,
                        opacity: this.opacity,
                        showLabels: this.showLabels
                    });
                }
            }

            updateNavigation() {
                this.prevBtn.disabled = this.currentStep === 0;
                this.nextBtn.disabled = this.currentStep >= this.steps.length - 1;
            }

            prevStep() {
                if (this.currentStep > 0) {
                    this.currentStep--;
                    this.updateStepDisplay();
                    this.updateNavigation();
                }
            }

            nextStep() {
                if (this.currentStep < this.steps.length - 1) {
                    this.currentStep++;
                    this.updateStepDisplay();
                    this.updateNavigation();
                }
            }

            togglePlay() {
                if (!this.isPlaying) {
                    this.isPlaying = true;
                    this.playBtn.textContent = '⏸ Pause';
                    this.currentStep = 0;
                    this.updateStepDisplay();
                    this.updateNavigation();
                    
                    this.playInterval = setInterval(() => {
                        if (this.currentStep < this.steps.length - 1) {
                            this.nextStep();
                        } else {
                            this.stopPlay();
                        }
                    }, 2000);
                } else {
                    this.stopPlay();
                }
            }

            stopPlay() {
                this.isPlaying = false;
                this.playBtn.textContent = '▶ Play';
                if (this.playInterval) {
                    clearInterval(this.playInterval);
                    this.playInterval = null;
                }
            }

            reset() {
                this.stopPlay();
                this.clearExpression();
            }

            hidePanel() {
                this.panelVisible = false;
                this.controlPanel.classList.add('hidden');
                this.togglePanelBtn.classList.remove('hidden');
            }

            showPanel() {
                this.panelVisible = true;
                this.controlPanel.classList.remove('hidden');
                this.togglePanelBtn.classList.add('hidden');
            }

            bindEvents() {
                // Symbol buttons
                document.querySelectorAll('.sym-btn[data-insert]').forEach(btn => {
                    btn.addEventListener('click', () => this.insertSymbol(btn.dataset.insert));
                });
                document.getElementById('backspace-btn').addEventListener('click', () => this.backspace());
                document.getElementById('clear-btn').addEventListener('click', () => this.clearExpression());

                // Navigation
                this.prevBtn.addEventListener('click', () => this.prevStep());
                this.nextBtn.addEventListener('click', () => this.nextStep());
                this.playBtn.addEventListener('click', () => this.togglePlay());
                this.resetBtn.addEventListener('click', () => this.reset());
                this.togglePanelBtn.addEventListener('click', () => this.showPanel());
                this.hidePanelBtn.addEventListener('click', () => this.hidePanel());

                this.opacitySlider.addEventListener('input', (e) => {
                    this.opacity = e.target.value / 100;
                    this.opacityValue.textContent = `${e.target.value}%`;
                    this.updateRender();
                });

                this.showLabelsCheckbox.addEventListener('change', (e) => {
                    this.showLabels = e.target.checked;
                    this.updateRender();
                });

                document.addEventListener('keydown', (e) => {
                    // Backspace key
                    if (e.key === 'Backspace') {
                        e.preventDefault();
                        this.backspace();
                        return;
                    }
                    switch (e.key) {
                        case 'ArrowLeft':
                            e.preventDefault();
                            this.prevStep();
                            break;
                        case 'ArrowRight':
                            e.preventDefault();
                            this.nextStep();
                            break;
                        case ' ':
                            e.preventDefault();
                            this.togglePlay();
                            break;
                        case 'r':
                        case 'R':
                            this.reset();
                            break;
                    }
                });
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            new VennVisualizer();
        });
    </script>
</body>
</html>
