<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Venn Diagram Visualizer</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0f1117;
            min-height: 100vh;
            width: 100vw;
            height: 100vh;
            display: flex;
            padding: 0;
            margin: 0;
            overflow: hidden;
        }

        #canvas-container {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #1a1d2e;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.4);
            min-width: 0;
            min-height: 0;
            overflow: hidden;
            margin: 10px;
        }

        canvas {
            max-width: 100%;
            max-height: 100%;
            width: auto;
            height: auto;
        }

        #control-panel {
            width: 300px;
            background: #1e2235;
            box-shadow: -4px 0 20px rgba(0,0,0,0.4);
            padding: 20px;
            z-index: 100;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
            transition: transform 0.3s ease, opacity 0.3s ease;
            font-family: 'JetBrains Mono', monospace;
        }

        #control-panel.hidden {
            transform: translateX(100%);
            opacity: 0;
            pointer-events: none;
            width: 0;
            padding: 0;
            overflow: hidden;
        }

        #toggle-panel-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 44px;
            height: 44px;
            background: #252b42;
            border: none;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.4);
            cursor: pointer;
            z-index: 101;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            color: #b8bfd4;
            transition: background 0.2s, transform 0.2s;
        }

        #toggle-panel-btn:hover {
            background: #2a3150;
            transform: scale(1.05);
        }

        #toggle-panel-btn.hidden {
            display: none;
        }

        @media (max-width: 900px) {
            body {
                flex-direction: column;
                height: auto;
                min-height: 100vh;
                overflow: auto;
            }

            #control-panel {
                width: 100%;
                box-shadow: 0 -4px 20px rgba(0,0,0,0.4);
                order: -1;
            }

            #canvas-container {
                width: 100%;
                min-height: 300px;
                margin: 10px;
            }
        }

        #control-panel h2 {
            font-size: 16px;
            margin-bottom: 15px;
            color: #b8bfd4;
            font-weight: 600;
        }

        .input-group {
            margin-bottom: 15px;
        }

        .input-group label {
            display: block;
            font-size: 12px;
            color: #8890aa;
            margin-bottom: 5px;
            font-weight: 500;
        }

        #expression-input {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid #2a3150;
            border-radius: 6px;
            font-size: 14px;
            font-family: 'JetBrains Mono', monospace;
            transition: border-color 0.2s;
        }

        #expression-input:focus {
            outline: none;
            border-color: #7b88c9;
        }

        #error-message {
            color: #c47e7e;
            font-size: 12px;
            margin-top: 5px;
            min-height: 16px;
        }

        .step-info {
            background: #252b42;
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 15px;
        }

        .step-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .step-number {
            font-size: 12px;
            color: #7b88c9;
            font-weight: 600;
        }

        .step-type {
            font-size: 11px;
            padding: 3px 8px;
            background: #2e3570;
            color: #9aa5d4;
            border-radius: 4px;
            font-weight: 500;
        }

        .step-description {
            font-size: 13px;
            color: #98a0bc;
            line-height: 1.4;
        }

        .nav-buttons {
            display: flex;
            gap: 8px;
            margin-bottom: 15px;
        }

        .nav-btn {
            flex: 1;
            padding: 8px 12px;
            border: 1px solid #2a3150;
            background: #252b42;
            color: #b8bfd4;
            border-radius: 6px;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
        }

        .nav-btn:hover:not(:disabled) {
            background: #2a3150;
            border-color: #3a4468;
        }

        .nav-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .settings-row {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }

        .settings-row .input-group {
            flex: 1;
            margin-bottom: 0;
        }

        select {
            width: 100%;
            padding: 8px 10px;
            border: 1px solid #2a3150;
            border-radius: 6px;
            font-size: 13px;
            background: #252b42;
            color: #b8bfd4;
            cursor: pointer;
        }

        select:focus {
            outline: none;
            border-color: #7b88c9;
        }

        .slider-container {
            margin-bottom: 15px;
        }

        .slider-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .slider-header label {
            font-size: 12px;
            color: #8890aa;
        }

        .slider-value {
            font-size: 12px;
            color: #b8bfd4;
            font-weight: 500;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #2a3150;
            appearance: none;
            cursor: pointer;
        }

        input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #7b88c9;
            cursor: pointer;
            transition: transform 0.1s;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.1);
        }

        .shortcuts {
            border-top: 1px solid #2a3150;
            padding-top: 15px;
            margin-top: 15px;
        }

        .shortcuts-title {
            font-size: 11px;
            color: #6b7494;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .shortcut {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            color: #8890aa;
            margin-bottom: 4px;
        }

        .shortcut kbd {
            background: #252b42;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: inherit;
            font-size: 11px;
        }

        #region-labels-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 15px;
        }

        #region-labels-toggle input[type="checkbox"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }

        #region-labels-toggle label {
            font-size: 13px;
            color: #8890aa;
            cursor: pointer;
        }

        #expression-display {
            min-height: 42px;
            padding: 8px 12px;
            border: 1px solid #2a3150;
            border-radius: 6px;
            font-size: 18px;
            font-family: 'JetBrains Mono', monospace;
            background: #252b42;
            color: #d0d5e8;
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 1px;
            word-break: break-all;
            transition: border-color 0.2s;
        }

        #expression-display:focus-within,
        #expression-display.active {
            border-color: #7b88c9;
            background: #2a3150;
        }

        #expression-display .cursor {
            display: inline-block;
            color: #7b88c9;
            font-weight: 300;
            animation: blink 1s step-end infinite;
            margin-left: 1px;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50%       { opacity: 0; }
        }

        @keyframes morphFadeIn {
            from { opacity: 0; }
            to   { opacity: 1; }
        }

        @keyframes morphPulse {
            0%   { opacity: 1; }
            50%  { opacity: 0.5; }
            100% { opacity: 1; }
        }

        @keyframes morphMerge {
            0%   { opacity: 1; }
            30%  { opacity: 0.8; }
            100% { opacity: 0; }
        }

        :root {
            --morph-enter-dur: 0.4s;
            --morph-pulse-dur: 0.6s;
            --morph-exit-dur:  0.5s;
        }

        .morph-layer-enter {
            animation: morphFadeIn var(--morph-enter-dur) ease forwards;
        }

        .morph-layer-pulse {
            animation: morphPulse var(--morph-pulse-dur) ease;
        }

        .morph-layer-exit {
            animation: morphMerge var(--morph-exit-dur) ease forwards;
        }

        .symbol-buttons {
            display: flex;
            flex-direction: column;
            gap: 6px;
            margin-bottom: 15px;
        }

        .symbol-row {
            display: flex;
            gap: 6px;
        }

        .sym-btn {
            flex: 1;
            padding: 10px 4px;
            font-size: 16px;
            font-family: 'JetBrains Mono', monospace;
            border: 1px solid #2a3150;
            border-radius: 6px;
            background: #252b42;
            color: #d0d5e8;
            cursor: pointer;
            transition: background 0.15s, border-color 0.15s, transform 0.1s;
            user-select: none;
        }

        .sym-btn:hover {
            background: #2a3150;
            border-color: #3a4468;
        }

        .sym-btn:active {
            transform: scale(0.93);
            background: #2e3570;
            border-color: #7b88c9;
        }

        .var-btn {
            font-weight: 600;
            color: #9aa5d4;
            border-color: #3b4470;
            background: #252d55;
        }

        .var-btn:hover {
            background: #2e3570;
            border-color: #4d5a8a;
        }

        .action-btn {
            font-size: 13px;
            color: #8890aa;
        }

        #clear-btn {
            color: #c47e7e;
            border-color: #6b3535;
            background: #2d1f1f;
        }

        #clear-btn:hover {
            background: #3d2525;
            border-color: #8a4a4a;
        }
    </style>
</head>
<body>
    <div id="canvas-container">
        <div id="venn-container" style="width: 100%; height: 100%; display: flex; justify-content: center; align-items: center;"></div>
    </div>

    <div id="control-panel">
            <h2>Venn Diagram Visualizer</h2>

            <div class="input-group">
                <label>Expression</label>
                <div id="expression-display"><span id="expression-text"></span><span class="cursor">|</span></div>
                <div id="error-message"></div>
            </div>

            <div class="symbol-buttons">
                <div class="symbol-row">
                    <button class="sym-btn var-btn" data-insert="A">A</button>
                    <button class="sym-btn var-btn" data-insert="B">B</button>
                    <button class="sym-btn var-btn" data-insert="C">C</button>
                    <button class="sym-btn" data-insert="′">′</button>
                </div>
                <div class="symbol-row">
                    <button class="sym-btn" data-insert="∪">∪</button>
                    <button class="sym-btn" data-insert="∩">∩</button>
                    <button class="sym-btn" data-insert="(">(</button>
                    <button class="sym-btn" data-insert=")">)</button>
                </div>
                <div class="symbol-row">
                    <button class="sym-btn action-btn" id="clear-btn">Clear</button>
                    <button class="sym-btn action-btn" id="backspace-btn">⌫</button>
                </div>
            </div>

            <div class="step-info" id="step-info" style="display: none;">
                <div class="step-header">
                    <span class="step-number" id="step-number">Step 1 of 7</span>
                    <span class="step-type" id="step-type">Parse</span>
                </div>
                <div class="step-description" id="step-description">
                    Parsing the expression...
                </div>
            </div>

            <div class="nav-buttons">
                <button class="nav-btn" id="prev-btn" disabled>◀ Prev</button>
                <button class="nav-btn" id="play-btn">▶ Play</button>
                <button class="nav-btn" id="next-btn" disabled>Next ▶</button>
                <button class="nav-btn" id="reset-btn">R Reset</button>
            </div>

            <div class="slider-container">
                <div class="slider-header">
                    <label>Opacity</label>
                    <span class="slider-value" id="opacity-value">38%</span>
                </div>
                <input type="range" id="opacity-slider" min="10" max="100" value="38">
            </div>

            <div class="slider-container">
                <div class="slider-header">
                    <label>Anim Speed</label>
                    <span class="slider-value" id="speed-value">1×</span>
                </div>
                <input type="range" id="speed-slider" min="25" max="300" value="100" step="25">
            </div>

            <div id="region-labels-toggle">
                <input type="checkbox" id="show-labels" checked>
                <label for="show-labels">Show region labels</label>
            </div>

            <div class="shortcuts">
                <div class="shortcuts-title">Keyboard Shortcuts</div>
                <div class="shortcut"><span>Previous step</span><kbd>←</kbd></div>
                <div class="shortcut"><span>Next step</span><kbd>→</kbd></div>
                <div class="shortcut"><span>Play/Pause</span><kbd>Space</kbd></div>
                <div class="shortcut"><span>Reset</span><kbd>R</kbd></div>
                <div class="shortcut"><span>Backspace</span><kbd>⌫</kbd></div>
            </div>

            <button id="hide-panel-btn" style="margin-top: 15px; padding: 10px; background: #252b42; border: 1px solid #2a3150; border-radius: 6px; cursor: pointer; width: 100%; color: #8890aa; font-family: 'JetBrains Mono', monospace; font-size: 13px;">Hide Panel</button>
        </div>

    <button id="toggle-panel-btn" class="hidden">☰</button>

    <script>
        // ==================== TOKENIZER ====================
        // Symbols: ∪ = union (OR), ∩ = intersection (AND), ′ or ' = complement (postfix NOT)
        class Tokenizer {
            constructor(expression) {
                this.expression = expression;
                this.pos = 0;
                this.tokens = [];
            }

            tokenize() {
                while (this.pos < this.expression.length) {
                    const char = this.expression[this.pos];

                    if (/\s/.test(char)) {
                        this.pos++;
                        continue;
                    }

                    if (/[A-Ca-c]/.test(char)) {
                        this.tokens.push({ type: 'VARIABLE', value: char.toUpperCase() });
                        this.pos++;
                    } else if (char === '∪') {
                        this.tokens.push({ type: 'UNION', value: '∪' });
                        this.pos++;
                    } else if (char === '∩') {
                        this.tokens.push({ type: 'INTERSECT', value: '∩' });
                        this.pos++;
                    } else if (char === '′' || char === "'") {
                        this.tokens.push({ type: 'COMPLEMENT', value: '′' });
                        this.pos++;
                    } else if (char === '(') {
                        this.tokens.push({ type: 'LPAREN', value: '(' });
                        this.pos++;
                    } else if (char === ')') {
                        this.tokens.push({ type: 'RPAREN', value: ')' });
                        this.pos++;
                    } else {
                        throw new Error(`Invalid character: ${char}`);
                    }
                }
                return this.tokens;
            }
        }

        // ==================== PARSER ====================
        // Grammar (precedence low → high):
        //   expr       → union
        //   union      → intersect ( ∪ intersect )*
        //   intersect  → postfix   ( ∩ postfix   )*
        //   postfix    → primary ′*
        //   primary    → VARIABLE | '(' expr ')'
        class Parser {
            constructor(tokens) {
                this.tokens = tokens;
                this.pos = 0;
            }

            parse() {
                if (this.tokens.length === 0) throw new Error('Empty expression');
                const ast = this.parseUnion();
                if (this.pos < this.tokens.length) {
                    throw new Error(`Unexpected token: ${this.tokens[this.pos].value}`);
                }
                return ast;
            }

            parseUnion() {
                let left = this.parseIntersect();
                while (this.match('UNION')) {
                    const right = this.parseIntersect();
                    left = { type: 'OR', left, right };
                }
                return left;
            }

            parseIntersect() {
                let left = this.parsePostfix();
                while (this.match('INTERSECT')) {
                    const right = this.parsePostfix();
                    left = { type: 'AND', left, right };
                }
                return left;
            }

            parsePostfix() {
                let node = this.parsePrimary();
                while (this.match('COMPLEMENT')) {
                    node = { type: 'NOT', operand: node };
                }
                return node;
            }

            parsePrimary() {
                if (this.match('VARIABLE')) {
                    return { type: 'VARIABLE', value: this.tokens[this.pos - 1].value };
                }
                if (this.match('LPAREN')) {
                    const expr = this.parseUnion();
                    if (!this.match('RPAREN')) {
                        throw new Error('Missing closing parenthesis');
                    }
                    return expr;
                }
                throw new Error(`Unexpected token: ${this.tokens[this.pos]?.value || 'end of input'}`);
            }

            match(type) {
                if (this.pos < this.tokens.length && this.tokens[this.pos].type === type) {
                    this.pos++;
                    return true;
                }
                return false;
            }
        }

        // ==================== REGION MAPPER ====================
        class RegionMapper {
            static getRegionsForVariable(variable) {
                switch (variable) {
                    case 'A': return [1, 3, 5, 7];
                    case 'B': return [2, 3, 6, 7];
                    case 'C': return [4, 5, 6, 7];
                    default: return [];
                }
            }

            static getRegionsForAST(node) {
                switch (node.type) {
                    case 'VARIABLE':
                        return this.getRegionsForVariable(node.value);
                    case 'NOT':
                        const notRegions = this.getRegionsForAST(node.operand);
                        return [0, 1, 2, 3, 4, 5, 6, 7].filter(r => !notRegions.includes(r));
                    case 'AND':
                        const leftAnd = this.getRegionsForAST(node.left);
                        const rightAnd = this.getRegionsForAST(node.right);
                        return leftAnd.filter(r => rightAnd.includes(r));
                    case 'OR':
                        const leftOr = this.getRegionsForAST(node.left);
                        const rightOr = this.getRegionsForAST(node.right);
                        return [...new Set([...leftOr, ...rightOr])].sort((a, b) => a - b);
                    default:
                        return [];
                }
            }
        }

        // ==================== STEP GENERATOR ====================
        class StepGenerator {
            constructor() {
                this.steps = [];
            }

            generateSteps(ast, originalExpression) {
                this.steps = [];
                this.breakDownExpression(ast);
                return this.steps;
            }

            breakDownExpression(node, context = '') {
                if (!node) return;

                if (node.type === 'VARIABLE') {
                    const regions = RegionMapper.getRegionsForAST(node);
                    this.steps.push({
                        stepNumber: this.steps.length + 1,
                        type: 'Variable',
                        description: `Evaluate ${node.value}`,
                        expression: node.value,
                        regions: regions,
                        ast: node
                    });
                    return;
                }

                if (node.type === 'NOT') {
                    // First, break down the operand to show all its steps
                    this.breakDownExpression(node.operand, 'NOT');
                    
                    // Then add the negation step
                    const regions = RegionMapper.getRegionsForAST(node);
                    const operandExpr = this.astToString(node.operand);
                    this.steps.push({
                        stepNumber: this.steps.length + 1,
                        type: 'Negation',
                        description: `Apply NOT to result of (${operandExpr})`,
                        expression: `NOT (${operandExpr})`,
                        regions: regions,
                        ast: node
                    });
                    return;
                }

                if (node.type === 'AND' || node.type === 'OR') {
                    // Break down left side; snapshot its last step index before moving on
                    this.breakDownExpression(node.left);
                    const leftStepIndex = this.steps.length - 1;
                    // Break down right side; snapshot its last step index
                    this.breakDownExpression(node.right);
                    const rightStepIndex = this.steps.length - 1;

                    const regions = RegionMapper.getRegionsForAST(node);
                    const leftRegions = RegionMapper.getRegionsForAST(node.left);
                    const rightRegions = RegionMapper.getRegionsForAST(node.right);
                    const leftExpr = this.astToString(node.left);
                    const rightExpr = this.astToString(node.right);

                    this.steps.push({
                        stepNumber: this.steps.length + 1,
                        type: node.type === 'AND' ? 'Intersection' : 'Union',
                        description: `Combine (${leftExpr}) ${node.type} (${rightExpr})`,
                        expression: `(${leftExpr}) ${node.type} (${rightExpr})`,
                        regions: regions,
                        leftRegions: leftRegions,
                        rightRegions: rightRegions,
                        leftStepIndex: leftStepIndex,
                        rightStepIndex: rightStepIndex,
                        isCombineStep: true,
                        ast: node
                    });
                }
            }

            astToString(node) {
                if (!node) return '';
                if (node.type === 'VARIABLE') return node.value;
                if (node.type === 'NOT') return `(${this.astToString(node.operand)})′`;
                if (node.type === 'AND') return `(${this.astToString(node.left)} ∩ ${this.astToString(node.right)})`;
                if (node.type === 'OR')  return `(${this.astToString(node.left)} ∪ ${this.astToString(node.right)})`;
                return '';
            }

            extractVariables(node) {
                if (!node) return [];
                if (node.type === 'VARIABLE') return [node.value];
                if (node.type === 'NOT') return this.extractVariables(node.operand);
                if (node.type === 'AND' || node.type === 'OR') {
                    return [...new Set([...this.extractVariables(node.left), ...this.extractVariables(node.right)])].sort();
                }
                return [];
            }

            describeRegions(regions) {
                const names = {
                    0: 'outside',
                    1: 'A only',
                    2: 'B only',
                    3: 'A∩B',
                    4: 'C only',
                    5: 'A∩C',
                    6: 'B∩C',
                    7: 'A∩B∩C'
                };
                return regions.map(r => names[r]).join(', ');
            }
        }

        // ==================== VENN RENDERER ====================
        class VennRenderer {
            constructor(container) {
                this.container = container;
                this.width = 600;
                this.height = 600;
                this.svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                this.svg.setAttribute("viewBox", `0 0 ${this.width} ${this.height}`);
                this.svg.style.width = "100%";
                this.svg.style.height = "100%";
                this.container.appendChild(this.svg);

                this.calculateDimensions();
                this.createDefinitions();
                this.createRegionElements();
                this.morphLayerA = null;
                this.morphLayerB = null;
            }

            calculateDimensions() {
                this.samplePadding = Math.min(this.width, this.height) * 0.08;
                this.sampleRect = {
                    x: this.samplePadding,
                    y: this.samplePadding,
                    width: this.width - this.samplePadding * 2,
                    height: this.height - this.samplePadding * 2
                };

                const sampleCenterX = this.sampleRect.x + this.sampleRect.width / 2;
                const sampleCenterY = this.sampleRect.y + this.sampleRect.height / 2;
                const minDim = Math.min(this.sampleRect.width, this.sampleRect.height);

                this.circleRadius = minDim * 0.28;
                const offsetY = minDim * 0.15;
                const offsetX = minDim * 0.18;

                this.circleCenters = {
                    A: { x: sampleCenterX, y: sampleCenterY - offsetY },
                    B: { x: sampleCenterX - offsetX, y: sampleCenterY + offsetY },
                    C: { x: sampleCenterX + offsetX, y: sampleCenterY + offsetY }
                };
            }

            createDefinitions() {
                const defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");

                // Clip Paths
                ['A', 'B', 'C'].forEach(key => {
                    const clip = document.createElementNS("http://www.w3.org/2000/svg", "clipPath");
                    clip.id = `clip-${key}`;
                    const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                    circle.setAttribute("cx", this.circleCenters[key].x);
                    circle.setAttribute("cy", this.circleCenters[key].y);
                    circle.setAttribute("r", this.circleRadius);
                    clip.appendChild(circle);
                    defs.appendChild(clip);
                });

                // Patterns
                const createPattern = (id, width, height, content) => {
                    const p = document.createElementNS("http://www.w3.org/2000/svg", "pattern");
                    p.setAttribute("id", id);
                    p.setAttribute("patternUnits", "userSpaceOnUse");
                    p.setAttribute("width", width);
                    p.setAttribute("height", height);
                    p.innerHTML = content;
                    defs.appendChild(p);
                };

                // Base templates use COLOR_PLACEHOLDER, substituted at render time
                this.patternTemplates = {
                    diagonal:   { w: 10, h: 10, content: (c) => `<path d="M-1,1 l2,-2 M0,10 l10,-10 M9,11 l2,-2" stroke="${c}" stroke-width="1.5" />` },
                    crosshatch: { w: 10, h: 10, content: (c) => `<path d="M0,0 l10,10 M10,0 l-10,10" stroke="${c}" stroke-width="1.5" />` },
                    dots:       { w: 10, h: 10, content: (c) => `<circle cx="5" cy="5" r="2" fill="${c}" />` },
                    waves:      { w: 20, h: 10, content: (c) => `<path d="M0,5 Q5,0 10,5 T20,5" fill="none" stroke="${c}" stroke-width="1.5" />` },
                    grid:       { w: 15, h: 15, content: (c) => `<path d="M 15 0 L 0 0 0 15" fill="none" stroke="${c}" stroke-width="1.5" />` },
                };

                this.svg.appendChild(defs);
            }

            createRegionElements() {
                // Background (Sample Space)
                const sampleG = document.createElementNS("http://www.w3.org/2000/svg", "g");
                const sampleRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                sampleRect.setAttribute("x", this.sampleRect.x);
                sampleRect.setAttribute("y", this.sampleRect.y);
                sampleRect.setAttribute("width", this.sampleRect.width);
                sampleRect.setAttribute("height", this.sampleRect.height);
                sampleRect.setAttribute("fill", "none");
                sampleRect.setAttribute("stroke", "#3a4468");
                sampleRect.setAttribute("stroke-width", "2");
                sampleG.appendChild(sampleRect);

                const sampleText = document.createElementNS("http://www.w3.org/2000/svg", "text");
                sampleText.setAttribute("x", this.sampleRect.x + 12);
                sampleText.setAttribute("y", this.sampleRect.y + 20);
                sampleText.setAttribute("fill", "#6b7494");
                sampleText.textContent = "S";
                sampleText.style.font = "italic 14px serif";
                sampleG.appendChild(sampleText);
                this.svg.appendChild(sampleG);

                // Regions Layer
                this.regionsLayer = document.createElementNS("http://www.w3.org/2000/svg", "g");
                this.svg.appendChild(this.regionsLayer);

                this.regionElements = {};
                for (let i = 0; i < 8; i++) {
                    const el = this.buildRegionElement(i);
                    el.style.display = 'none';
                    this.regionsLayer.appendChild(el);
                    this.regionElements[i] = el;
                }

                // Boundaries
                const boundariesG = document.createElementNS("http://www.w3.org/2000/svg", "g");
                ['A', 'B', 'C'].forEach(key => {
                    const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                    circle.setAttribute("cx", this.circleCenters[key].x);
                    circle.setAttribute("cy", this.circleCenters[key].y);
                    circle.setAttribute("r", this.circleRadius);
                    circle.setAttribute("fill", "none");
                    circle.setAttribute("stroke", "#3a4468");
                    circle.setAttribute("stroke-width", "2");
                    boundariesG.appendChild(circle);
                });
                this.svg.appendChild(boundariesG);

                // Labels Layer
                this.labelsLayer = document.createElementNS("http://www.w3.org/2000/svg", "g");
                this.svg.appendChild(this.labelsLayer);
                
                this.drawSetLabels();
            }

            buildRegionElement(regionIndex) {
                const included = this.getRegionCircles(regionIndex);
                const all = ['A', 'B', 'C'];
                const excluded = all.filter(x => !included.includes(x));

                let content = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                content.setAttribute("x", this.sampleRect.x);
                content.setAttribute("y", this.sampleRect.y);
                content.setAttribute("width", this.sampleRect.width);
                content.setAttribute("height", this.sampleRect.height);
                content.classList.add("region-fill-rect");

                if (excluded.length > 0) {
                    const maskId = `mask-exclude-${excluded.join('')}`;
                    if (!document.getElementById(maskId)) {
                        const mask = document.createElementNS("http://www.w3.org/2000/svg", "mask");
                        mask.id = maskId;
                        
                        const bg = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                        bg.setAttribute("x", 0);
                        bg.setAttribute("y", 0);
                        bg.setAttribute("width", "100%");
                        bg.setAttribute("height", "100%");
                        bg.setAttribute("fill", "white");
                        mask.appendChild(bg);

                        excluded.forEach(key => {
                            const c = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                            c.setAttribute("cx", this.circleCenters[key].x);
                            c.setAttribute("cy", this.circleCenters[key].y);
                            c.setAttribute("r", this.circleRadius);
                            c.setAttribute("fill", "black");
                            mask.appendChild(c);
                        });
                        this.svg.querySelector("defs").appendChild(mask);
                    }
                    content.setAttribute("mask", `url(#${maskId})`);
                }

                let root = content;
                included.forEach(key => {
                    const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
                    g.setAttribute("clip-path", `url(#clip-${key})`);
                    g.appendChild(root);
                    root = g;
                });

                return root;
            }

            getRegionCircles(regionIndex) {
                const circles = {
                    0: [],
                    1: ['A'],
                    2: ['B'],
                    3: ['A', 'B'],
                    4: ['C'],
                    5: ['A', 'C'],
                    6: ['B', 'C'],
                    7: ['A', 'B', 'C']
                };
                return circles[regionIndex] || [];
            }

            resize() {
                // Not needed for SVG
            }

            // Ensure a color-baked SVG pattern exists in <defs> and return its fill reference.
            _ensurePattern(pattern, color) {
                if (pattern === 'solid') return color;
                const safeColor = color.replace('#', '');
                const patternId = `pattern-${pattern}-${safeColor}`;
                if (!this.svg.querySelector(`#${patternId}`)) {
                    const tmpl = this.patternTemplates[pattern];
                    if (tmpl) {
                        const p = document.createElementNS("http://www.w3.org/2000/svg", "pattern");
                        p.setAttribute("id", patternId);
                        p.setAttribute("patternUnits", "userSpaceOnUse");
                        p.setAttribute("width", tmpl.w);
                        p.setAttribute("height", tmpl.h);
                        p.innerHTML = tmpl.content(color);
                        this.svg.querySelector("defs").appendChild(p);
                    }
                }
                return `url(#${patternId})`;
            }

            render(shadedRegions, options = {}) {
                const { color = '#7b88c9', pattern = 'solid', opacity = 0.38, showLabels = true } = options;

                Object.values(this.regionElements).forEach(el => el.style.display = 'none');

                const fillRef = this._ensurePattern(pattern, color);

                shadedRegions.forEach(index => {
                    const el = this.regionElements[index];
                    if (!el) return;
                    el.style.display = 'inline';

                    let rect = el;
                    while (rect && !rect.classList?.contains("region-fill-rect")) {
                        rect = rect.firstElementChild;
                    }
                    if (rect) {
                        rect.setAttribute("fill", fillRef);
                        rect.setAttribute("fill-opacity", opacity);
                    }
                });

                const labelsGroup = this.svg.querySelector("#region-labels-group");
                if (labelsGroup) {
                    labelsGroup.style.display = showLabels ? 'inline' : 'none';
                } else if (showLabels) {
                    this.drawLabels();
                }
            }

            drawLabels() {
                let g = this.svg.querySelector("#region-labels-group");
                if (!g) {
                    g = document.createElementNS("http://www.w3.org/2000/svg", "g");
                    g.id = "region-labels-group";
                    this.labelsLayer.appendChild(g);

                    const fontSize = Math.max(10, this.width * 0.018);
                    
                    const a = this.circleCenters.A;
                    const b = this.circleCenters.B;
                    const c = this.circleCenters.C;
                    const r = this.circleRadius * 0.4;

                    const positions = {
                        1: { x: a.x - r * 0.7, y: a.y - r * 0.4 },
                        2: { x: b.x - r * 0.3, y: b.y + r * 0.2 },
                        4: { x: c.x + r * 0.3, y: c.y + r * 0.2 },
                        3: { x: (a.x + b.x) / 2 - r * 0.2, y: (a.y + b.y) / 2 },
                        5: { x: (a.x + c.x) / 2 + r * 0.2, y: (a.y + c.y) / 2 },
                        6: { x: (b.x + c.x) / 2, y: (b.y + c.y) / 2 + r * 0.8 },
                        7: { x: (a.x + b.x + c.x) / 3, y: (a.y + b.y + c.y) / 3 }
                    };

                    const labels = { 1: 'A', 2: 'B', 4: 'C', 3: 'AB', 5: 'AC', 6: 'BC', 7: 'ABC' };

                    Object.entries(positions).forEach(([region, pos]) => {
                        const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
                        text.setAttribute("x", pos.x);
                        text.setAttribute("y", pos.y);
                        text.setAttribute("text-anchor", "middle");
                        text.setAttribute("fill", "#6b7494");
                        text.style.font = `${fontSize}px sans-serif`;
                        text.textContent = labels[region];
                        g.appendChild(text);
                    });
                }
                g.style.display = 'inline';
            }

            // ---- Morph animation helpers ----

            // Render multiple region groups each with their own color/pattern in a single pass.
            // Later groups overwrite earlier ones for any shared regions.
            renderMulti(groups, options = {}) {
                const { opacity = 0.38, showLabels = true } = options;

                Object.values(this.regionElements).forEach(el => el.style.display = 'none');

                groups.forEach(({ regions, color, pattern }) => {
                    const fillRef = this._ensurePattern(pattern || 'solid', color || '#7b88c9');
                    regions.forEach(index => {
                        const el = this.regionElements[index];
                        if (!el) return;
                        el.style.display = 'inline';
                        let rect = el;
                        while (rect && !rect.classList?.contains("region-fill-rect")) {
                            rect = rect.firstElementChild;
                        }
                        if (rect) {
                            rect.setAttribute("fill", fillRef);
                            rect.setAttribute("fill-opacity", opacity);
                        }
                    });
                });

                const labelsGroup = this.svg.querySelector("#region-labels-group");
                if (labelsGroup) {
                    labelsGroup.style.display = showLabels ? 'inline' : 'none';
                } else if (showLabels) {
                    this.drawLabels();
                }
            }

            // Build a ghost layer group with a given color/pattern. Returns the <g> (not attached).
            _buildMorphGroup(shadedRegions, color, pattern, opacity) {
                const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
                g.setAttribute("pointer-events", "none");

                const fillRef = this._ensurePattern(pattern || 'solid', color);

                shadedRegions.forEach(index => {
                    const original = this.regionElements[index];
                    if (!original) return;
                    const clone = original.cloneNode(true);
                    clone.style.display = 'inline';

                    let rect = clone;
                    while (rect && !rect.classList?.contains("region-fill-rect")) {
                        rect = rect.firstElementChild;
                    }
                    if (rect) {
                        rect.setAttribute("fill", fillRef);
                        rect.setAttribute("fill-opacity", opacity);
                    }
                    g.appendChild(clone);
                });

                return g;
            }

            // Show two region sets simultaneously with distinct colors/patterns (for the morph animation).
            // Returns the two layer group elements so the caller can animate them.
            renderDual(leftRegions, rightRegions, leftColor, leftPattern, rightColor, rightPattern, opacity) {
                // Remove any previous morph layers
                this.clearMorphLayer();

                this.morphLayerA = this._buildMorphGroup(leftRegions,  leftColor,  leftPattern,  opacity);
                this.morphLayerB = this._buildMorphGroup(rightRegions, rightColor, rightPattern, opacity);

                // Insert morph layers above regionsLayer but below boundariesG / labelsLayer
                // They go right after regionsLayer
                this.regionsLayer.after(this.morphLayerA);
                this.morphLayerA.after(this.morphLayerB);

                return { layerA: this.morphLayerA, layerB: this.morphLayerB };
            }

            // Remove morph overlay layers from the SVG
            clearMorphLayer() {
                if (this.morphLayerA && this.morphLayerA.parentNode) {
                    this.morphLayerA.parentNode.removeChild(this.morphLayerA);
                }
                if (this.morphLayerB && this.morphLayerB.parentNode) {
                    this.morphLayerB.parentNode.removeChild(this.morphLayerB);
                }
                this.morphLayerA = null;
                this.morphLayerB = null;
            }

            drawSetLabels() {
                const fontSize = Math.max(12, this.width * 0.028);
                const offset = this.circleRadius * 0.75;
                
                const createLabel = (text, x, y) => {
                    const t = document.createElementNS("http://www.w3.org/2000/svg", "text");
                    t.setAttribute("x", x);
                    t.setAttribute("y", y);
                    t.setAttribute("text-anchor", "middle");
                    t.setAttribute("fill", "#b8bfd4");
                    t.style.font = `bold ${fontSize}px sans-serif`;
                    t.textContent = text;
                    this.labelsLayer.appendChild(t);
                };

                createLabel('A', this.circleCenters.A.x, this.circleCenters.A.y - offset);
                createLabel('B', this.circleCenters.B.x - offset * 0.65, this.circleCenters.B.y + offset * 0.85);
                createLabel('C', this.circleCenters.C.x + offset * 0.65, this.circleCenters.C.y + offset * 0.85);
            }
        }

        // ==================== MAIN APPLICATION ====================
        class VennVisualizer {
            constructor() {
                this.container = document.getElementById('venn-container');
                this.renderer = new VennRenderer(this.container);
                this.expressionText = document.getElementById('expression-text');
                this.errorMessage = document.getElementById('error-message');
                this.stepInfo = document.getElementById('step-info');
                this.stepNumber = document.getElementById('step-number');
                this.stepType = document.getElementById('step-type');
                this.stepDescription = document.getElementById('step-description');
                this.prevBtn = document.getElementById('prev-btn');
                this.nextBtn = document.getElementById('next-btn');
                this.playBtn = document.getElementById('play-btn');
                this.resetBtn = document.getElementById('reset-btn');
                this.opacitySlider = document.getElementById('opacity-slider');
                this.opacityValue = document.getElementById('opacity-value');
                this.speedSlider = document.getElementById('speed-slider');
                this.speedValue = document.getElementById('speed-value');
                this.showLabelsCheckbox = document.getElementById('show-labels');
                this.controlPanel = document.getElementById('control-panel');
                this.togglePanelBtn = document.getElementById('toggle-panel-btn');
                this.hidePanelBtn = document.getElementById('hide-panel-btn');

                // Expression state — built by symbol buttons
                this.expression = '';

                this.steps = [];
                this.currentStep = 0;
                this.isPlaying = false;
                this.playInterval = null;
                this.panelVisible = true;

                this.colorPalette = [
                    '#7b88c9', '#c47e7e', '#7db87d', '#c4a97e',
                    '#a07bc9', '#c47ea8', '#7bbab4', '#8896b5'
                ];

                this.patternOptions = ['solid', 'diagonal', 'crosshatch', 'dots', 'waves', 'grid'];

                this.opacity = 0.38;
                this.animSpeed = 1.0;
                this.showLabels = true;
                this.stepColors   = [];
                this.stepPatterns = [];
                this._morphTimeouts = [];
                this._morphAnimating = false;

                this.bindEvents();
                this.initialRender();
            }

            // Append a symbol to the expression and re-evaluate
            insertSymbol(sym) {
                this.expression += sym;
                this.expressionText.textContent = this.expression;
                this.errorMessage.textContent = '';
                this.visualize();
            }

            // Remove last character and re-evaluate
            backspace() {
                if (this.expression.length === 0) return;
                // Handle multi-byte characters (∪ ∩ ′ are single Unicode code points)
                this.expression = [...this.expression].slice(0, -1).join('');
                this.expressionText.textContent = this.expression;
                this.errorMessage.textContent = '';
                if (this.expression.length === 0) {
                    this.steps = [];
                    this.stepInfo.style.display = 'none';
                    this.initialRender();
                    this.updateNavigation();
                } else {
                    this.visualize();
                }
            }

            // Clear the entire expression
            clearExpression() {
                this.expression = '';
                this.expressionText.textContent = '';
                this.errorMessage.textContent = '';
                this.steps = [];
                this.stepInfo.style.display = 'none';
                this.initialRender();
                this.updateNavigation();
            }

            initialRender() {
                this.renderer.render([], { opacity: this.opacity, showLabels: this.showLabels });
            }

            visualize() {
                const expression = this.expression.trim();

                if (!expression) {
                    return;
                }

                try {
                    const tokenizer = new Tokenizer(expression);
                    const tokens = tokenizer.tokenize();

                    const parser = new Parser(tokens);
                    const ast = parser.parse();

                    const stepGenerator = new StepGenerator();
                    this.steps = stepGenerator.generateSteps(ast, expression);

                    // Assign a unique (color, pattern) to each step for this expression.
                    const shuffledColors   = this._shuffle([...this.colorPalette]);
                    const shuffledPatterns = this._shuffle([...this.patternOptions]);
                    this.stepColors   = this.steps.map((_, i) => shuffledColors[i % shuffledColors.length]);
                    this.stepPatterns = this.steps.map((_, i) => shuffledPatterns[i % shuffledPatterns.length]);

                    this.currentStep = this.steps.length - 1;
                    this.errorMessage.textContent = '';

                    if (this.steps.length > 0) {
                        this.stepInfo.style.display = 'block';
                        this.updateStepDisplay();
                        this.updateNavigation();
                    }
                } catch (error) {
                    this.errorMessage.textContent = error.message;
                }
            }

            updateStepDisplay(animate = false) {
                if (this.currentStep >= this.steps.length) {
                    this.currentStep = this.steps.length - 1;
                }

                if (this.currentStep < 0) {
                    this.currentStep = 0;
                }

                const step        = this.steps[this.currentStep];
                const stepColor   = this.stepColors[this.currentStep]   || this.colorPalette[0];
                const stepPattern = this.stepPatterns[this.currentStep] || 'solid';

                this.stepNumber.textContent = `Step ${this.currentStep + 1} of ${this.steps.length}`;
                this.stepType.textContent = step.type;
                this.stepDescription.textContent = step.description;

                // Run morph animation for combine steps when navigating forward
                if (animate && step.isCombineStep && step.leftRegions && step.rightRegions) {
                    this.animateCombine(step, this.currentStep);
                } else {
                    this._cancelMorphAnimation();
                    if (step.isCombineStep) {
                        const leftColor   = this.stepColors[step.leftStepIndex]   || this.colorPalette[0];
                        const leftPattern = this.stepPatterns[step.leftStepIndex] || 'solid';
                        const rightColor   = this.stepColors[step.rightStepIndex]   || this.colorPalette[1];
                        const rightPattern = this.stepPatterns[step.rightStepIndex] || 'solid';
                        const leftResult  = step.leftRegions.filter(r => step.regions.includes(r));
                        const rightResult = step.rightRegions.filter(r => step.regions.includes(r));
                        this.renderer.renderMulti([
                            { regions: leftResult,  color: leftColor,  pattern: leftPattern },
                            { regions: rightResult, color: rightColor, pattern: rightPattern }
                        ], { opacity: this.opacity, showLabels: this.showLabels });
                    } else {
                        this.renderer.render(step.regions, {
                            color: stepColor, pattern: stepPattern,
                            opacity: this.opacity, showLabels: this.showLabels
                        });
                    }
                }
            }

            updateRender() {
                if (this.steps.length > 0 && this.currentStep < this.steps.length) {
                    const step = this.steps[this.currentStep];
                    if (step.isCombineStep) {
                        const leftColor   = this.stepColors[step.leftStepIndex]   || this.colorPalette[0];
                        const leftPattern = this.stepPatterns[step.leftStepIndex] || 'solid';
                        const rightColor   = this.stepColors[step.rightStepIndex]   || this.colorPalette[1];
                        const rightPattern = this.stepPatterns[step.rightStepIndex] || 'solid';
                        const leftResult  = step.leftRegions.filter(r => step.regions.includes(r));
                        const rightResult = step.rightRegions.filter(r => step.regions.includes(r));
                        this.renderer.renderMulti([
                            { regions: leftResult,  color: leftColor,  pattern: leftPattern },
                            { regions: rightResult, color: rightColor, pattern: rightPattern }
                        ], { opacity: this.opacity, showLabels: this.showLabels });
                    } else {
                        const stepColor   = this.stepColors[this.currentStep]   || this.colorPalette[0];
                        const stepPattern = this.stepPatterns[this.currentStep] || 'solid';
                        this.renderer.render(step.regions, {
                            color: stepColor, pattern: stepPattern,
                            opacity: this.opacity, showLabels: this.showLabels
                        });
                    }
                }
            }

            // Cancel any in-progress morph animation
            _cancelMorphAnimation() {
                if (this._morphTimeouts) {
                    this._morphTimeouts.forEach(id => clearTimeout(id));
                }
                this._morphTimeouts = [];
                this._morphAnimating = false;
                this.renderer.clearMorphLayer();
            }

            // Run the 3-phase morph animation for a combine step.
            // Phase 1 (0ms):    Show left operand regions in left step's color, overlay on blank base
            // Phase 2 (700ms):  Fade in right operand regions in right step's color alongside left
            // Phase 3 (1800ms): Dissolve both layers away, snap to the final combined render
            animateCombine(step, stepIndex) {
                this._cancelMorphAnimation();
                this._morphAnimating = true;
                this._morphTimeouts = [];

                const leftColor   = this.stepColors[step.leftStepIndex]   || this.colorPalette[0];
                const leftPattern = this.stepPatterns[step.leftStepIndex] || 'solid';
                const rightColor   = this.stepColors[step.rightStepIndex]   || this.colorPalette[1];
                const rightPattern = this.stepPatterns[step.rightStepIndex] || 'solid';
                const opacity = this.opacity;

                // Phase 1: blank base, overlay both full operand layers in their source colors/patterns
                this.renderer.render([], { opacity, showLabels: this.showLabels });
                const { layerA, layerB } = this.renderer.renderDual(
                    step.leftRegions, step.rightRegions,
                    leftColor, leftPattern, rightColor, rightPattern, opacity
                );

                // Start layerA visible, layerB hidden (will fade in)
                layerA.style.opacity = '1';
                layerB.style.opacity = '0';
                layerA.classList.add('morph-layer-enter');

                const s = 1 / this.animSpeed; // scale factor: lower speed → larger s → longer delays

                // Phase 2 (700ms): fade in layerB alongside layerA
                const t1 = setTimeout(() => {
                    layerB.style.transition = `opacity ${0.4 * s}s ease`;
                    layerB.style.opacity = '1';
                }, 700 * s);
                this._morphTimeouts.push(t1);

                // Phase 2b (1300ms): pulse both layers to signal merging
                const t2 = setTimeout(() => {
                    layerA.classList.add('morph-layer-pulse');
                    layerB.classList.add('morph-layer-pulse');
                }, 1300 * s);
                this._morphTimeouts.push(t2);

                // Phase 3 (1800ms): dissolve morph layers away, reveal combined final render
                const t3 = setTimeout(() => {
                    layerA.classList.add('morph-layer-exit');
                    layerB.classList.add('morph-layer-exit');

                    // Snap to result: only regions in the final result, each in its source color/pattern.
                    // Left regions rendered first; right overwrites any overlap.
                    const leftResult  = step.leftRegions.filter(r => step.regions.includes(r));
                    const rightResult = step.rightRegions.filter(r => step.regions.includes(r));
                    this.renderer.renderMulti([
                        { regions: leftResult,  color: leftColor,  pattern: leftPattern },
                        { regions: rightResult, color: rightColor, pattern: rightPattern }
                    ], { opacity, showLabels: this.showLabels });
                }, 1800 * s);
                this._morphTimeouts.push(t3);

                // Phase 3 cleanup (2350ms): remove morph layers completely
                const t4 = setTimeout(() => {
                    this.renderer.clearMorphLayer();
                    this._morphAnimating = false;
                }, 2350 * s);
                this._morphTimeouts.push(t4);
            }

            _shuffle(arr) {
                for (let i = arr.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [arr[i], arr[j]] = [arr[j], arr[i]];
                }
                return arr;
            }

            updateNavigation() {
                this.prevBtn.disabled = this.currentStep === 0;
                this.nextBtn.disabled = this.currentStep >= this.steps.length - 1;
            }

            prevStep() {
                if (this.currentStep > 0) {
                    this.currentStep--;
                    this.updateStepDisplay(false); // no animation when going backwards
                    this.updateNavigation();
                }
            }

            nextStep() {
                if (this.currentStep < this.steps.length - 1) {
                    this.currentStep++;
                    this.updateStepDisplay(true); // animate combine steps on forward navigation
                    this.updateNavigation();
                }
            }

            togglePlay() {
                if (!this.isPlaying) {
                    this.isPlaying = true;
                    this.playBtn.textContent = '⏸ Pause';
                    this.currentStep = 0;
                    this.updateStepDisplay(true);
                    this.updateNavigation();

                    const scheduleNext = () => {
                        if (!this.isPlaying) return;
                        // If a morph animation is running, wait for it to finish before advancing
                        const step = this.steps[this.currentStep];
                        const delay = ((step && step.isCombineStep) ? 2600 : 2000) / this.animSpeed;
                        this.playInterval = setTimeout(() => {
                            if (!this.isPlaying) return;
                            if (this.currentStep < this.steps.length - 1) {
                                this.currentStep++;
                                this.updateStepDisplay(true);
                                this.updateNavigation();
                                scheduleNext();
                            } else {
                                this.stopPlay();
                            }
                        }, delay);
                    };

                    scheduleNext();
                } else {
                    this.stopPlay();
                }
            }

            stopPlay() {
                this.isPlaying = false;
                this.playBtn.textContent = '▶ Play';
                if (this.playInterval) {
                    clearTimeout(this.playInterval);
                    this.playInterval = null;
                }
                this._cancelMorphAnimation();
            }

            reset() {
                this.stopPlay();
                this.clearExpression();
            }

            hidePanel() {
                this.panelVisible = false;
                this.controlPanel.classList.add('hidden');
                this.togglePanelBtn.classList.remove('hidden');
            }

            showPanel() {
                this.panelVisible = true;
                this.controlPanel.classList.remove('hidden');
                this.togglePanelBtn.classList.add('hidden');
            }

            bindEvents() {
                // Symbol buttons
                document.querySelectorAll('.sym-btn[data-insert]').forEach(btn => {
                    btn.addEventListener('click', () => this.insertSymbol(btn.dataset.insert));
                });
                document.getElementById('backspace-btn').addEventListener('click', () => this.backspace());
                document.getElementById('clear-btn').addEventListener('click', () => this.clearExpression());

                // Navigation
                this.prevBtn.addEventListener('click', () => this.prevStep());
                this.nextBtn.addEventListener('click', () => this.nextStep());
                this.playBtn.addEventListener('click', () => this.togglePlay());
                this.resetBtn.addEventListener('click', () => this.reset());
                this.togglePanelBtn.addEventListener('click', () => this.showPanel());
                this.hidePanelBtn.addEventListener('click', () => this.hidePanel());

                this.opacitySlider.addEventListener('input', (e) => {
                    this.opacity = e.target.value / 100;
                    this.opacityValue.textContent = `${e.target.value}%`;
                    this.updateRender();
                });

                this.speedSlider.addEventListener('input', (e) => {
                    this.animSpeed = e.target.value / 100;
                    const label = this.animSpeed === 1 ? '1×' : `${this.animSpeed.toFixed(2).replace(/\.?0+$/, '')}×`;
                    this.speedValue.textContent = label;
                    // Update CSS custom properties so running CSS animations scale too
                    const root = document.documentElement;
                    const s = 1 / this.animSpeed;
                    root.style.setProperty('--morph-enter-dur', `${0.4 * s}s`);
                    root.style.setProperty('--morph-pulse-dur', `${0.6 * s}s`);
                    root.style.setProperty('--morph-exit-dur',  `${0.5 * s}s`);
                });

                this.showLabelsCheckbox.addEventListener('change', (e) => {
                    this.showLabels = e.target.checked;
                    this.updateRender();
                });

                document.addEventListener('keydown', (e) => {
                    // Backspace key
                    if (e.key === 'Backspace') {
                        e.preventDefault();
                        this.backspace();
                        return;
                    }
                    switch (e.key) {
                        case 'ArrowLeft':
                            e.preventDefault();
                            this.prevStep();
                            break;
                        case 'ArrowRight':
                            e.preventDefault();
                            this.nextStep();
                            break;
                        case ' ':
                            e.preventDefault();
                            this.togglePlay();
                            break;
                        case 'r':
                        case 'R':
                            this.reset();
                            break;
                    }
                });
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            new VennVisualizer();
        });
    </script>
</body>
</html>
